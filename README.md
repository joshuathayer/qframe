## Declarative, reactive layouts for Python/Qt

qframe is a library for declarative interface building in Python/Qt, and for binding UI state to a single data structure in your application.

Here's how things fit together:

### Your layout is a data structure

For example

    ['vbox', {'id','todos'}, ['label', {'id': 'todo0'}, 'Go surf']
                             ['label', {'id': 'todo1'}, 'Drink coffee']]

### Your layout data structure is generated by components

Components are just functions which accept some stateful data. Here's a todo list component:

    def todos(state):
        items = state['todo-items']
        container = ['vbox/inbox-list', {}]

        for item in items:
            container.append(['label', {'id': item['id']}, item['msg']])

        return container

And here's how to integrate the todo list into a larger layout:

    ['vbox', {'id': 'container'},
      [['label', {'id':'headline'}, "Here are my to-dos"],
       ['todos', {'id':'todo-list'}]]

### All of your UI state is stored in a single data structure

In the example above, the `todos` component is passed its data as a `state` argument. Where does that data come from?

It's derived from a single "database" dictionary that your application maintains. In the example above, this could look like:

    {...
     'todo-items': [{'id': 0, 'msg': "Go surf"},
                    {'id': 1, 'msg': "Drink coffee"}],
     ...}

### Components are reactive to changes in the state database

As the state database changes, component functions which "subscribe" to a part of the DB which has changed get rerun, and any changes to the layout are applied to the UI.

So, this state DB:

    {...
     'todo-items': [{'id': 0, 'msg': "Go surf"},
                    {'id': 1, 'msg': "Drink coffee"}],
     ...}

Will yield this layout:

    ['vbox', {'id','todos'}, ['label', {'id': 'todo0'}, 'Go surf'],
                             ['label', {'id': 'todo1'}, 'Drink coffee']]

And changing the state DB to:

    {...
     'todo-items': [{'id': 0, 'msg': "Go surf in Bolinas"},
                    {'id': 1, 'msg': "Drink coffee"},
                    {'id': 2, 'msg': "Do code review"}],
     ...}

Will _automatically_ update the layout to

    ['vbox', {'id','todos'}, ['label', {'id': 'todo0'}, 'Go surf in Bolinas'],
                             ['label', {'id': 'todo1'}, 'Drink coffee'],
                             ['label', {'id': 'todo2'}, 'Do code review']]

And your UI will automatically be updated as well.

## Closing the circle

The sketch above describes the flow of data _from_ the state BD to the UI, but doesn't describe how the state DB gets updated.

This process is less well developed in qframe, but I think there's a natural fit with the actor implementation I've been playing with: [spot](https://github.com/joshuathayer/spot). A single "DB" actor could be responsible for performing updates on the state DB, and would receive messages from other actors wishing to make updates.

`example.py` in this repo shows this pattern, for a simple actor network which updates a `time` key in the state DB:

    class Timer:
        def act(self, msg, tell, create):
            tell('updater','click')
            tell('timer','click')

    class DBUpdater:
        def __init__(self, db):
            self.db = db

        def act(self, msg, tell, create):
            self.db.assoc_in(['time'], time.time())

    system = spot.system.ActorSystem(qapp)
    system.create_actor(Timer(), 'timer')
    system.create_actor(DBUpdater(db), 'updater')

    # kick off the actor network
    system.tell('timer','click')


## interested reading

qframe is a simplification and reinterpretation of the wonderful ClojureScript library [re-frame](https://github.com/Day8/re-frame).

qframe uses [reactive-qt](https://github.com/joshuathayer/reactive-qt) to do layout diffing and operation-based Qt updating.
