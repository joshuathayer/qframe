## Declarative, reactive layouts for Python/Qt

qframe is a library for declarative interface building with unidirectional data binding for Python/Qt.

Here's how things fit together:

### Your layout is a data structure

Your _entire_ application UI is represented with a single Python data structure.

For example

    ['vbox', {'id','todos'}, ['label', {'id': 'todo0'}, 'Go surf']
                             ['label', {'id': 'todo1'}, 'Drink coffee']]

represents (and is rederable to) an interface made of a PyQt `vbox` containing two PyQt `labels` wth the text "Go surf" and "Drink coffee".

### Your layout data structure is generated by components

Since our layout is just data, we can write code to dynamically build our full UI. You can think of that process as being a _pure function of the state of the application_.

qframe abstracts that idea with "components".

Components are just functions which accept some stateful data and return valid "layout" data. Here's a todo list component. It's a function which takes a `state` dictionary which should have a value at 'todo-items', a returns a `vbox` with a `label` for every element found at `todo-items`.

    def todos(state):
        items = state['todo-items']
        container = ['vbox/inbox-list', {}]

        for item in items:
            container.append(['label', {'id': item['id']}, item['msg']])

        return container

When your component functions are decorated with the `@component` decorator, they can be used in your declarative layouts. When we properly decorate `todos` above, we'd can use it symbolically in a bigger layout:

    ['vbox', {'id': 'container'},
      [['label', {'id':'headline'}, "Here are my to-dos"],
       ['todos', {'id':'todo-list'}]]

### All of your UI state is stored in a single data structure

In the example above, the `todos` component is passed its data as a `state` argument. Where does that data come from?

It's derived from a single "database" dictionary that your application maintains. In the example above, this could look like:

    {...
     'todo-items': [{'id': 0, 'msg': "Go surf"},
                    {'id': 1, 'msg': "Drink coffee"}],
     ...}

### Components are reactive to changes in the state database

As the state database changes, component functions which "subscribe" to a part of the DB which has changed get rerun, and any changes to the layout are applied to the UI.

As we've seen, this state DB:

    {...
     'todo-items': [{'id': 0, 'msg': "Go surf"},
                    {'id': 1, 'msg': "Drink coffee"}],
     ...}

Will yield this layout:

    ['vbox', {'id','todos'}, ['label', {'id': 'todo0'}, 'Go surf'],
                             ['label', {'id': 'todo1'}, 'Drink coffee']]

The magic happens here. Changing the state DB to:

    {...
     'todo-items': [{'id': 0, 'msg': "Go surf in Bolinas"},
                    {'id': 1, 'msg': "Drink coffee"},
                    {'id': 2, 'msg': "Do code review"}],
     ...}

Will _automatically_ update the layout data structure to

    ['vbox', {'id','todos'}, ['label', {'id': 'todo0'}, 'Go surf in Bolinas'],
                             ['label', {'id': 'todo1'}, 'Drink coffee'],
                             ['label', {'id': 'todo2'}, 'Do code review']]

And your UI will automatically be updated as well.

## Closing the circle

The sketch above describes the flow of data _from_ the state DB to the UI, but doesn't describe how the state DB gets updated.

This process is less well developed in qframe, but I think there's a natural fit with the actor implementation I've been playing with: [spot](https://github.com/joshuathayer/spot). A single "DB" actor could be responsible for performing updates on the state DB, and would receive messages from other actors wishing to make updates.

`todo_example.py` in this repo shows this pattern.

## interested reading

qframe is a simplification and reinterpretation of the wonderful ClojureScript library [re-frame](https://github.com/Day8/re-frame).

qframe uses [reactive-qt](https://github.com/joshuathayer/reactive-qt) to do layout diffing and operation-based Qt updating.
